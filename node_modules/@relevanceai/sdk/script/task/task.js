"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Task = exports.resetBackoffDuration = void 0;
const emitter_js_1 = require("../emitter.js");
const utils_js_1 = require("../utils.js");
const event_js_1 = require("../event.js");
exports.resetBackoffDuration = Symbol("resetBackoffDuration");
const backoffStartingDuration = 1_000;
const backoffMaxDuration = 60_000;
class Task extends emitter_js_1.Emitter {
    subscribed = null;
    backoff = null;
    backoffDuration = 0;
    strategy;
    #metadata;
    constructor(metadata, strategy) {
        super();
        this.strategy = strategy;
        this.#metadata = metadata;
    }
    get subject() {
        return this.strategy.subject;
    }
    get id() {
        return this.#metadata.id;
    }
    get region() {
        return this.#metadata.region;
    }
    get project() {
        return this.#metadata.project;
    }
    get name() {
        return this.#metadata.name;
    }
    get status() {
        return this.#metadata.status;
    }
    get createdAt() {
        return this.#metadata.createdAt;
    }
    get updatedAt() {
        return this.#metadata.updatedAt;
    }
    getMessages(options) {
        return this.strategy.getMessages(options);
    }
    isRunning() {
        switch (this.status) {
            case "queued":
            case "running":
                return true;
            default:
                return false;
        }
    }
    #subscribe() {
        if (this.subscribed) {
            return;
        }
        const subscribed = new AbortController();
        this.subscribed = subscribed; // subscribed ref
        const isSubscribed = () => !subscribed.signal.aborted;
        this.backoffDuration = backoffStartingDuration;
        const cursor = new Date();
        const emitted = new Set();
        const pending = new Map();
        void (async () => {
            while (isSubscribed()) {
                try {
                    const [metadata, messages] = await Promise.all([
                        this.strategy.getMetadata(),
                        this.strategy.getMessages({ after: cursor }),
                    ]);
                    if (!isSubscribed()) {
                        break;
                    }
                    let hasChanges = false;
                    if (metadata.updatedAt > this.updatedAt) {
                        this.dispatchEvent(new event_js_1.TaskUpdateEvent());
                        hasChanges = true;
                    }
                    this.#metadata = metadata;
                    if (messages.length) {
                        for (const message of messages) {
                            if (emitted.has(message.id)) {
                                continue;
                            }
                            switch (message.type) {
                                case "agent-error":
                                    emitted.add(message.id);
                                    this.dispatchEvent(new event_js_1.TaskErrorEvent(message));
                                    break;
                                case "tool-run": {
                                    const { status } = message;
                                    if (pending.get(message.id)?.status == status) {
                                        // no change to the tool status
                                        continue;
                                    }
                                    if (["pending", "running"].includes(status)) {
                                        pending.set(message.id, message);
                                    }
                                    else {
                                        emitted.add(message.id);
                                        pending.delete(message.id);
                                    }
                                    this.dispatchEvent(new event_js_1.TaskMessageEvent(message));
                                    break;
                                }
                                case "agent-message":
                                case "user-message":
                                    hasChanges = true;
                                    emitted.add(message.id);
                                    this.dispatchEvent(new event_js_1.TaskMessageEvent(message));
                            }
                        }
                        let latest = messages.at(-1).createdAt;
                        for (const message of pending.values()) {
                            if (latest > message.createdAt) {
                                latest = message.createdAt;
                            }
                        }
                        cursor.setTime(latest.getTime());
                    }
                    if (hasChanges) {
                        this.backoffDuration = backoffStartingDuration;
                    }
                    else if (!this.isRunning()) {
                        this.backoffDuration = Math.min(this.backoffDuration * 2, backoffMaxDuration);
                    }
                }
                finally {
                    if (isSubscribed()) {
                        const backoff = new AbortController();
                        this.backoff = backoff;
                        await Promise.race([
                            (0, utils_js_1.delay)(this.backoffDuration),
                            (0, utils_js_1.abortPromise)(AbortSignal.any([subscribed.signal, backoff.signal])),
                        ]);
                    }
                }
            }
        })();
    }
    unsubscribe() {
        this.subscribed?.abort();
        this.subscribed = null;
        this.backoff?.abort();
        this.backoff = null;
        this.backoffDuration = 0;
    }
    [exports.resetBackoffDuration]() {
        this.backoffDuration = backoffStartingDuration;
        this.backoff?.abort();
    }
    addEventListener(type, listener, options) {
        this.#subscribe();
        const signal = AbortSignal.any([
            ...(options && typeof options === "object" && options.signal
                ? [options.signal]
                : []),
            ...(this.subscribed ? [this.subscribed.signal] : []),
        ]);
        const capture = typeof options === "boolean"
            ? options
            : Boolean(options?.capture);
        const addOptions = Object.assign({}, options, { signal, capture });
        super.addEventListener(type, listener, addOptions);
    }
}
exports.Task = Task;
