"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = void 0;
exports.stateToStatus = stateToStatus;
const client_js_1 = require("./client.js");
const utils_js_1 = require("./utils.js");
const agent_strategy_js_1 = require("./task/agent-strategy.js");
const task_js_1 = require("./task/task.js");
const const_js_1 = require("./const.js");
/**
 * Converts an AgentTaskState to a simplified TaskStatus.
 *
 * @dev
 *   We want to simplify because our states are simplified in the UI and also
 *   some states have combined reasoning that the consumer does not need to care
 *   about. i.e. "queued-for-approval" "queued-for-rerun" should just be "queued".
 *
 * @param {AgentTaskState} state The agent task state to convert.
 * @returns {TaskStatus} The simplified task status.
 */
function stateToStatus(state) {
    switch (state) {
        case "paused":
            return "paused";
        case "idle":
            return "idle";
        case "starting-up":
        case "waiting-for-capacity":
        case "queued-for-approval":
        case "queued-for-rerun":
            return "queued";
        case "running":
            return "running";
        case "pending-approval":
        case "escalated":
            return "action";
        case "timed-out":
            return "error";
        case "cancelled":
            return "cancelled";
        case "completed":
            return "completed";
        case "unrecoverable":
        case "errored-pending-approval":
            return "error";
        default:
            throw new Error(`unhandled task state: ${state}`);
    }
}
/**
 * Reverses {@link stateToStatus} returning the group of task states a _simplified_
 * status may relate to.
 *
 * @see {stateToStatus}
 * @param {TaskStatus} status
 * @returns {AgentTaskState[]}
 */
function statusToStates(status) {
    switch (status) {
        case "not-started":
            // a special sdk-only status
            return [];
        case "idle":
            return ["idle"];
        case "paused":
            return ["paused"];
        case "queued":
            return [
                "starting-up",
                "waiting-for-capacity",
                "queued-for-approval",
                "queued-for-rerun",
            ];
        case "running":
            return ["running"];
        case "action":
            return ["pending-approval", "escalated"];
        case "completed":
            return ["completed"];
        case "cancelled":
            return ["cancelled"];
        case "error":
            return ["errored-pending-approval", "timed-out", "unrecoverable"];
    }
}
function taskSortOptionsToParam(sort) {
    if ("createdAt" in sort) {
        return { insert_date: sort.createdAt };
    }
    else if ("updatedAt" in sort) {
        return { update_date: sort.updatedAt };
    }
    throw new Error("invalid sort option");
}
class Agent {
    static async get(id, client = client_js_1.Client.default()) {
        const config = await Agent.#fetchConfig(id, client);
        return new Agent(config, client);
    }
    static async getAll({ page = 1, pageSize = 20, } = {}, client = client_js_1.Client.default()) {
        const { results } = await client.fetch("/agents/list", {
            method: "POST",
            body: JSON.stringify({
                page_size: pageSize,
                page,
            }),
        });
        return results.map((config) => new Agent(config, client));
    }
    static #fetchConfig(agentId, client = client_js_1.Client.default()) {
        return client.fetch(`/agents/${agentId}/get`).then(({ agent }) => agent);
    }
    #config;
    client;
    constructor(config, client) {
        this.client = client;
        this.#config = config;
    }
    get id() {
        return this.#config.agent_id;
    }
    get region() {
        return this.client.region;
    }
    get project() {
        return this.#config.project;
    }
    get name() {
        return this.#config.name;
    }
    get description() {
        return this.#config.description;
    }
    get avatar() {
        return this.#config.emoji;
    }
    get createdAt() {
        return new Date(this.#config.insert_date_);
    }
    get updatedAt() {
        return new Date(this.#config.update_date_);
    }
    getTask(taskId) {
        return agent_strategy_js_1.AgentStrategy.get(taskId, this, this.client);
    }
    async getTasks({ sort = { createdAt: "asc" }, pageSize = 100, page = 1, search, filter, } = {}) {
        const filtersParam = [{
                condition: "==",
                condition_value: [this.id],
                field: "conversation.agent_id",
                filter_type: "exact_match",
            }];
        if (filter) {
            for (const [field, value] of Object.entries(filter)) {
                switch (field) {
                    case "status":
                        filtersParam.push({
                            condition: "==",
                            condition_value: value.flatMap((s) => statusToStates(s)),
                            field: "conversation.state",
                            filter_type: "exact_match",
                        });
                }
            }
        }
        const sortParam = taskSortOptionsToParam(sort);
        const query = new URLSearchParams([
            ["filters", JSON.stringify(filtersParam)],
            ["sort", JSON.stringify([sortParam])],
            ["page_size", pageSize.toString()],
            ["page", page.toString()],
        ]);
        if (search?.trim()) {
            query.set("query", search.trim());
        }
        const { results } = await this.client.fetch(`/agents/conversations/list?${query.toString()}`);
        return results.map(({ metadata }) => new task_js_1.Task({
            id: metadata.knowledge_set,
            region: this.client.region,
            project: this.client.project,
            name: metadata.conversation.title,
            status: stateToStatus(metadata.conversation.state),
            createdAt: new Date(metadata.insert_date),
            updatedAt: new Date(metadata.update_date),
        }, new agent_strategy_js_1.AgentStrategy(metadata.knowledge_set, this, this.client)));
    }
    async sendMessage(message, attachOrTask, maybeTask) {
        const hasAttachments = Array.isArray(attachOrTask);
        const attachFiles = hasAttachments ? attachOrTask : [];
        const task = hasAttachments ? maybeTask : attachOrTask;
        let taskId;
        // embed keys require a task prefixing for new tasks
        if (!task && this.client.isEmbedKey()) {
            taskId = [this.client.key.taskPrefix, await (0, utils_js_1.randomUUID)()].join(const_js_1.TASK_PREFIX_DELIM);
        }
        else if (task) {
            taskId = task.id;
        }
        const attachments = [];
        for (const item of attachFiles) {
            attachments.push(item instanceof File ? await this.client.uploadTempFile(item) : item);
        }
        const res = await this.client.fetch("/agents/trigger", {
            method: "POST",
            body: JSON.stringify({
                agent_id: this.#config.agent_id,
                conversation_id: taskId,
                message: {
                    role: "user",
                    content: message,
                    attachments: attachments.map(({ fileName, fileUrl }) => ({
                        file_name: fileName,
                        file_url: fileUrl,
                    })),
                },
            }),
        });
        if (task) {
            task[task_js_1.resetBackoffDuration]();
        }
        return task ?? await this.getTask(res.conversation_id);
    }
}
exports.Agent = Agent;
