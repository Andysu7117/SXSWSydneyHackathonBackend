import { Emitter } from "../emitter.js";
import type { AnyTaskMessage } from "../message/task.js";
import type { Region } from "../region.js";
import type { Workforce } from "../workforce.js";
import type { Agent } from "../agent.js";
import type { AgentErrorMessage } from "../message/agent-error.js";
export type TaskStatus = "not-started" | "idle" | "paused" | "queued" | "running" | "action" | "completed" | "cancelled" | "error";
export interface TaskMetadata {
    id: string;
    region: Region;
    project: string;
    status: TaskStatus;
    name: string;
    createdAt: Date;
    updatedAt: Date;
}
type TaskEventMap = {
    updated: undefined;
    message: {
        message: AnyTaskMessage;
    };
    error: {
        message: AgentErrorMessage;
    };
};
export interface TaskStrategy<S> {
    subject: S;
    getMessages(options?: {
        after?: Date;
    }): Promise<AnyTaskMessage[]>;
    getMetadata(): Promise<TaskMetadata>;
}
export declare const resetBackoffDuration: unique symbol;
export declare class Task<S extends Agent | Workforce, E extends TaskEventMap = TaskEventMap> extends Emitter<E> {
    #private;
    private subscribed;
    private backoff;
    private backoffDuration;
    private readonly strategy;
    constructor(metadata: TaskMetadata, strategy: TaskStrategy<S>);
    get subject(): S;
    get id(): string;
    get region(): Region;
    get project(): string;
    get name(): string;
    get status(): TaskStatus;
    get createdAt(): Date;
    get updatedAt(): Date;
    getMessages(options?: {
        after?: Date;
    }): Promise<AnyTaskMessage[]>;
    isRunning(): boolean;
    unsubscribe(): void;
    [resetBackoffDuration](): void;
    addEventListener<K extends keyof E>(type: Extract<K, string>, listener: ((event: CustomEvent<E[K]>) => void) | {
        handleEvent: (event: CustomEvent<E[K]>) => void;
    } | null, options?: boolean | AddEventListenerOptions): void;
}
export {};
