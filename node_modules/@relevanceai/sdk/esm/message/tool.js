import { GenericMessage } from "./task.js";
import { Tool } from "../tool.js";
export class ToolMessage extends GenericMessage {
    tool;
    constructor(message) {
        super(message);
        if (message.content.tool_config.type === "tool") {
            const { id, ...config } = message.content.tool_config;
            this.tool = new Tool({ studio_id: id, ...config });
        }
        // @todo: subagent
    }
    /**
     * The tool status for _this_ message.
     *
     * @property {ToolStatus}
     */
    // deno-lint-ignore getter-return
    get status() {
        const status = this.message.content.tool_run_state;
        switch (status) {
            case "cancelled":
            case "pending":
            case "running":
            case "error":
                return status;
            // agents and tools have different end statuses, align them
            case "finished":
                return "completed";
        }
    }
    /**
     * Parameters used to call the tool.
     *
     * @property {object}
     */
    get params() {
        return this.message.content.params.resolved ?? null;
    }
    /**
     * The tool's output. Will be `null` if the status is **not** "finished".
     *
     * @property {object|null}
     */
    get output() {
        return this.status === "completed" ? this.message.content.output : null;
    }
    /**
     * Tool errors.
     *
     * @property {array}
     * @see {@link ToolMessage#hasErrors}
     */
    get errors() {
        return this.message.content.errors.map((e) => ({
            stepName: e.step_name,
            message: e.body,
        }));
    }
    /**
     * The tool or agent ID.
     *
     * @property {string}
     */
    get toolOrAgentId() {
        return this.message.content.tool_config.id;
    }
    /**
     * The agent's ID, if a sub-agent.
     *
     * @property {string}
     * @see {@link ToolMessage#isSubAgent}
     */
    get agentId() {
        return this.isSubAgent()
            ? this.message.content.output._agent_conversation_details?.agent_id
            : null;
    }
    /**
     * The tool/agent's corresponding project.
     *
     * @property {string}
     */
    get project() {
        return this.message.content.tool_config.project;
    }
    /**
     * The tool/agent's corresponding region.
     *
     * @property {Region}
     */
    get region() {
        return this.message.content.tool_config.region;
    }
    /**
     * The task ID the subagent ran. Will be `null` if the tool message is not
     * a subagent.
     *
     * @property {string}
     * @see {@link ToolMessage.isSubAgent}
     */
    get subAgentTaskId() {
        return this.message.content.output._agent_conversation_details
            ?.conversation_id ?? null;
    }
    /**
     * Checks if the tool message came from a sub-agent.
     *
     * @returns {boolean}
     */
    isSubAgent() {
        return this.message.content.tool_config.type === "agent";
    }
    /**
     * Checks if the tool call parameters where valid.
     *
     * @returns {boolean}
     */
    areParamsValid() {
        return this.message.content.params.valid;
    }
    /**
     * Returns if the tool message has any errors.
     *
     * @returns {boolean}
     */
    hasErrors() {
        return this.message.content.errors.length > 0;
    }
    /**
     * Checks if the tool message is currently running. Note that pending tools
     * are also classified as running as they are just scheduled for running.
     *
     * @returns {boolean}
     */
    isRunning() {
        switch (this.status) {
            case "pending":
            case "running":
                return true;
            default:
                return false;
        }
    }
}
